// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"doublequote"
	"doublequote/asynq"
	"doublequote/blob"
	"doublequote/crypto"
	"doublequote/http"
	"doublequote/ingest"
	"doublequote/redis"
	"doublequote/sql"
)

// Injectors from wire.go:

func initializeApplication(cfg *dq.Config) (*application, func(), error) {
	sqlSQL, cleanup, err := setupSQL(cfg)
	if err != nil {
		return nil, nil, err
	}
	eventService, cleanup2, err := setupEventService(cfg)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	cryptoService := setupCryptoService(cfg)
	userService := sql.NewUserService(sqlSQL, eventService, cryptoService)
	cacheService, err := setupCache(cfg)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	sessionService := redis.NewSessionService(cacheService)
	entryService := setupEntryService(sqlSQL)
	storageService, cleanup3, err := setupStorageService(cfg)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	feedService := setupFeedService(sqlSQL)
	ingestService := setupIngestService(feedService, entryService, storageService)
	collectionService := sql.NewCollectionService(sqlSQL)
	server, cleanup4, err := setupServer(cfg, userService, cryptoService, sessionService, storageService, ingestService, collectionService, feedService)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	mainApplication := newApplication(userService, cryptoService, sessionService, entryService, storageService, server)
	return mainApplication, func() {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

// wire.go:

type application struct {
	userService       dq.UserService
	cryptoService     dq.CryptoService
	sessionService    dq.SessionService
	collectionService dq.CollectionService
	entryService      dq.EntryService
	storageService    dq.StorageService
	ingestService     dq.IngestService

	httpServer *http.Server
}

func setupSQL(cfg *dq.Config) (*sql.SQL, func(), error) {
	d := sql.NewSQL(cfg.Database.URL)

	err := d.Open()
	if err != nil {
		return nil, nil, err
	}

	return d, func() {
		d.Close()
	}, nil
}

func setupCache(cfg *dq.Config) (*redis.CacheService, error) {
	d := redis.NewCache(cfg.Redis.URL)

	return d, nil
}

func setupEventService(cfg *dq.Config) (dq.EventService, func(), error) {
	s := asynq.NewEventService(cfg.Redis.URL)

	err := s.Open()
	if err != nil {
		return nil, nil, err
	}

	return s, func() {
		s.Close()
	}, nil
}

func setupCryptoService(cfg *dq.Config) dq.CryptoService {
	s := crypto.NewService(cfg.App.Secret)
	return s
}

func setupServer(
	cfg *dq.Config,
	userService dq.UserService,
	cryptoService dq.CryptoService,
	sessionService dq.SessionService,
	storageService dq.StorageService,
	ingestService dq.IngestService,
	collectionService dq.CollectionService,
	feedService dq.FeedService,
) (*http.Server, func(), error) {
	s := http.NewServer()

	s.CryptoService = cryptoService
	s.UserService = userService
	s.SessionService = sessionService
	s.CollectionService = collectionService
	s.FeedService = feedService
	s.StorageService = storageService
	s.IngestService = ingestService
	s.Config = *cfg

	err := s.Open()
	if err != nil {
		return nil, nil, err
	}

	return s, func() {
		s.Close()
	}, nil
}

func setupFeedService(
	s *sql.SQL,
) dq.FeedService {
	return sql.NewFeedService(s)
}

func setupEntryService(
	s *sql.SQL,
) dq.EntryService {
	return sql.NewEntryService(s)
}

func setupIngestService(
	feedService dq.FeedService,
	entryService dq.EntryService,
	storageService dq.StorageService,
) dq.IngestService {
	return ingest.NewService(feedService, entryService, storageService)
}

func setupStorageService(
	cfg *dq.Config,
) (dq.StorageService, func(), error) {
	a, b, c := blob.NewStorageService(cfg.App.BucketName)
	return a, func() {
		b()
	}, c
}

func newApplication(
	userService dq.UserService,
	cryptoService dq.CryptoService,
	sessionService dq.SessionService,
	entryService dq.EntryService,
	storageService dq.StorageService,
	server *http.Server,
) *application {
	return &application{
		userService:    userService,
		cryptoService:  cryptoService,
		sessionService: sessionService,
		entryService:   entryService,
		storageService: storageService,
		httpServer:     server,
	}
}
